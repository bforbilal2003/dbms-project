CREATE TABLE User1 (
    email VARCHAR(255) PRIMARY KEY NOT NULL,
    name VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
	lastLogin TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX user_email_idx ON 1User1 (email);

CREATE TABLE reservationId (
    id INT PRIMARY KEY
);

INSERT INTO reservationId VALUES(120);

INSERT INTO "User" VALUES('ctfce', 'rfc', 'rcf', '2022-02-20');

CREATE TABLE reservation (
    reservationID INT PRIMARY KEY,
    reservedBy VARCHAR(30),
    roomType VARCHAR(20),
    reservationDate DATE,
    checkoutDate DATE,
    FOREIGN KEY (reservedBy) REFERENCES User1(email),
    FOREIGN KEY (reservationID) REFERENCES reservationId(id)
);

CREATE INDEX reservation_reservedBy_index ON reservation (reservedBy);
CREATE INDEX reservation_reservationID_index ON reservation (reservationID);

CREATE TABLE delux (
    reservationID INT PRIMARY KEY,
    price INT,
    isAvailable BOOLEAN,
    maxNoOfPeople INT
);

CREATE TABLE premium (
    reservationID INT PRIMARY KEY,
    price INT,
    isAvailable BOOLEAN,
    maxNoOfPeople INT
);

CREATE TABLE suite (
    reservationID INT PRIMARY KEY,
    price INT,
    isAvailable BOOLEAN,
    maxNoOfPeople INT
);

INSERT INTO delux VALUES(1, 100, true, 2);
INSERT INTO premium VALUES(1, 500, true, 4);
INSERT INTO suite VALUES(1, 1000, true, 5);

CREATE OR REPLACE FUNCTION UpdateReservationIdTrigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO reservation (reservationID, reservedBy, roomType, reservationDate, checkoutDate)
    VALUES (NEW.id, NULL, NULL, NULL, NULL);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_reservation_id_trigger
AFTER UPDATE ON reservationId
FOR EACH ROW
EXECUTE FUNCTION UpdateReservationIdTrigger();

DELETE FROM reservationId WHERE id=100;

CREATE OR REPLACE FUNCTION InsertIntoRoomTables()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.roomType = 'delux') THEN
        INSERT INTO delux (reservationID, price, isAvailable, maxNoOfPeople)
        VALUES (NEW.reservationID, 100, true, 2);
    ELSIF (NEW.roomType = 'premium') THEN
        INSERT INTO premium (reservationID, price, isAvailable, maxNoOfPeople)
        VALUES (NEW.reservationID, 150, true, 4);
    ELSE
        INSERT INTO suite (reservationID, price, isAvailable, maxNoOfPeople)
        VALUES (NEW.reservationID, 200, true, 6);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_into_room_tables_trigger
AFTER INSERT ON reservation
FOR EACH ROW
EXECUTE FUNCTION InsertIntoRoomTables();

CREATE TRIGGER insert_into_room_tables_trigger
AFTER INSERT ON reservation
FOR EACH ROW
EXECUTE FUNCTION InsertIntoRoomTables();

CREATE OR REPLACE PROCEDURE GetUserReservationsCursor(
    IN currentUserEmail VARCHAR(30)
)
LANGUAGE plpgsql
AS $$
DECLARE
    user_reservation_cursor CURSOR FOR
        SELECT u.email, u.name, r.reservationID, r.roomType, r.reservationDate, r.checkoutDate
        FROM "User" u
        INNER JOIN reservation r ON u.email = r.reservedBy
        WHERE u.email = currentUserEmail;
    row_record RECORD;
BEGIN
    -- Open the cursor
    OPEN user_reservation_cursor;

    -- Fetch rows from the cursor and return each row
    FOR row_record IN user_reservation_cursor LOOP
        -- Output each row to the result set
        -- This is equivalent to RETURN NEXT in a set-returning function
        SELECT row_record.email, row_record.name, row_record.reservationID, row_record.roomType, row_record.reservationDate, row_record.checkoutDate;
    END LOOP;

    -- Close the cursor
    CLOSE user_reservation_cursor;
END;
$$;
